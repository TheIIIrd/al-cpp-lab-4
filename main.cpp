/*
Лабораторная работа 4. Использование объектов своих классов в
последовательных контейнерах библиотеки STL.

В приложении организовать контейнер объектов своего класса
(элементы контейнера - объекты класса, не указатели!!!).

Класс должен иметь необходимые конструкторы, конструктор копирования
и перемещения при необходимости (обосновать отсутствие или наличие
необходимости), перегруженные операции присваивания с копированием и
перемещением при необходимости (обосновать отсутствие или наличие
необходимости), перегруженную операцию вставки в поток <<.

Обеспечить копирование одного контейнера в другой с помощью алгоритма
std::copy. А также сортировку объектов в исходном контейнере,для
шаблона vector или deque при сортировке использовать алгоритм std::sort
с двумя параметрами: итератор на начало и итератор на конец контейнера.

Исходные данные прочитать из текстового файла input.txt. Вывести в
выходной файл output.txt исходный контейнер, контейнер после сортировки,
использовать при этом перегруженную операцию вставки в поток, также
вывести в выходной файл контейнер, в который скопирован исходный контейнер.

+ Объект - автомобиль
(поля: название модели, массив расходов топлива из 3-х элементов
(на трассе, в городе, смешанный), максимальная скорость, мощность)
+ Сортировка по смешанному расходу топлива
+ Исходный контейнер vector, копируем в deque
*/

#include "vehicle.hpp" // Подключение заголовочного файла с описанием класса Vehicle
#include <algorithm>
#include <deque>
#include <fstream>
#include <vector>

template <class T> void CustomOutput(T &_TMP) {
  std::ofstream output("output.txt",
                       std::ios::app); // Открытие файла для записи

  output << _TMP << std::endl;    // Запись объекта в файл
  std::cout << _TMP << std::endl; // Вывод объекта на консоль

  output.close(); // Закрытие файла
}

int main() {
  std::ofstream clear("output.txt"); // Очистка файла вывода
  clear.close();                     // Закрытие файла

  std::ifstream input("input.txt"); // Открытие файла для чтения

  std::vector<Vehicle> _TEST; // Создание вектора объектов класса Vehicle

  for (size_t i = 0; i < 5; ++i) {
    Vehicle _TMP; // Создание временного объекта Vehicle
    input >> _TMP; // Чтение данных из файла и инициализация объекта
    _TEST.push_back(_TMP); // Добавление объекта в конец вектора
  }

  CustomOutput(
      "[+] List before Sorting: "); // Вывод заголовка списка перед сортировкой
  for (const auto &_EL : _TEST) {
    CustomOutput(_EL); // Вывод каждого элемента из вектора
  }

  CustomOutput(
      "[+] List after Sorting: "); // Вывод заголовка списка после сортировки
  std::sort(_TEST.begin(), _TEST.end()); // Сортировка элементов вектора

  for (auto _EL : _TEST) {
    CustomOutput(_EL); // Вывод отсортированных элементов
  }

  CustomOutput("[+] Vector copied from List: "); // Вывод заголовка для
                                                 // скопированного вектора
  std::deque<Vehicle> _RES; // Создание двусвязного списка объектов Vehicle

  std::copy(
      _TEST.begin(), _TEST.end(),
      std::back_inserter(_RES)); // Копирование элементов из вектора в список

  for (const auto &_EL : _RES) {
    CustomOutput(_EL); // Вывод каждого элемента из скопированного списка
  }

  return 0;
}
